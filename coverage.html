
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>oas2jsonschema: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/krateoplatformops/oasgen-provider/internal/tools/oas2jsonschema/oas_adapter.go (97.2%)</option>
				
				<option value="file1">github.com/krateoplatformops/oasgen-provider/internal/tools/oas2jsonschema/oas_generator.go (78.5%)</option>
				
				<option value="file2">github.com/krateoplatformops/oasgen-provider/internal/tools/oas2jsonschema/oas_getters.go (100.0%)</option>
				
				<option value="file3">github.com/krateoplatformops/oasgen-provider/internal/tools/oas2jsonschema/oas_validator.go (100.0%)</option>
				
				<option value="file4">github.com/krateoplatformops/oasgen-provider/internal/tools/oas2jsonschema/test_mocks.go (100.0%)</option>
				
				<option value="file5">github.com/krateoplatformops/oasgen-provider/internal/tools/oas2jsonschema/types.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package oas2jsonschema

import (
        "strconv"

        "github.com/pb33f/libopenapi"
        "github.com/pb33f/libopenapi/datamodel/high/base"
        v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
        "github.com/pb33f/libopenapi/orderedmap"
)

// --- Adapter Implementation ---

type libOASDocumentAdapter struct {
        doc *libopenapi.DocumentModel[v3.Document]
}

// We implement the OASDocument interface for the libopenapi DocumentModel
func NewLibOASDocumentAdapter(doc *libopenapi.DocumentModel[v3.Document]) OASDocument <span class="cov8" title="1">{
        return &amp;libOASDocumentAdapter{doc: doc}
}</span>

func (a *libOASDocumentAdapter) FindPath(path string) (PathItem, bool) <span class="cov8" title="1">{
        p, ok := a.doc.Model.Paths.PathItems.Get(path)
        if !ok </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        <span class="cov8" title="1">return &amp;libOASPathItemAdapter{path: p}, true</span>
}

func (a *libOASDocumentAdapter) SecuritySchemes() []SecuritySchemeInfo <span class="cov8" title="1">{
        if a.doc.Model.Components == nil || a.doc.Model.Components.SecuritySchemes == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">var schemes []SecuritySchemeInfo
        for pair := a.doc.Model.Components.SecuritySchemes.First(); pair != nil; pair = pair.Next() </span><span class="cov8" title="1">{
                v := pair.Value()
                schemes = append(schemes, SecuritySchemeInfo{
                        Name:      pair.Key(),
                        Type:      SecuritySchemeType(v.Type),
                        Scheme:    v.Scheme,
                        In:        v.In,
                        ParamName: v.Name,
                })
        }</span>
        <span class="cov8" title="1">return schemes</span>
}

type libOASPathItemAdapter struct {
        path *v3.PathItem
}

func (a *libOASPathItemAdapter) GetOperations() map[string]Operation <span class="cov8" title="1">{
        ops := make(map[string]Operation)
        rawOps := a.path.GetOperations()
        for pair := rawOps.First(); pair != nil; pair = pair.Next() </span><span class="cov8" title="1">{
                ops[pair.Key()] = &amp;libOASOperationAdapter{op: pair.Value()}
        }</span>
        <span class="cov8" title="1">return ops</span>
}

type libOASOperationAdapter struct {
        op *v3.Operation
}

func (a *libOASOperationAdapter) GetParameters() []ParameterInfo <span class="cov8" title="1">{
        var params []ParameterInfo
        for _, p := range a.op.Parameters </span><span class="cov8" title="1">{
                params = append(params, ParameterInfo{
                        Name:        p.Name,
                        In:          p.In,
                        Description: p.Description,
                        Schema:      convertLibopenapiSchema(p.Schema),
                })
        }</span>
        <span class="cov8" title="1">return params</span>
}

func (a *libOASOperationAdapter) GetRequestBody() RequestBodyInfo <span class="cov8" title="1">{
        if a.op.RequestBody == nil || a.op.RequestBody.Content == nil </span><span class="cov8" title="1">{
                return RequestBodyInfo{}
        }</span>
        <span class="cov8" title="1">content := make(map[string]*Schema)
        for pair := a.op.RequestBody.Content.First(); pair != nil; pair = pair.Next() </span><span class="cov8" title="1">{
                content[pair.Key()] = convertLibopenapiSchema(pair.Value().Schema)
        }</span>
        <span class="cov8" title="1">return RequestBodyInfo{Content: content}</span>
}

func (a *libOASOperationAdapter) GetResponses() map[int]ResponseInfo <span class="cov8" title="1">{
        if a.op.Responses == nil || a.op.Responses.Codes == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">responses := make(map[int]ResponseInfo)
        for pair := a.op.Responses.Codes.First(); pair != nil; pair = pair.Next() </span><span class="cov8" title="1">{
                code, err := strconv.Atoi(pair.Key())
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">content := make(map[string]*Schema)
                if pair.Value().Content != nil </span><span class="cov8" title="1">{
                        for contentPair := pair.Value().Content.First(); contentPair != nil; contentPair = contentPair.Next() </span><span class="cov8" title="1">{
                                content[contentPair.Key()] = convertLibopenapiSchema(contentPair.Value().Schema)
                        }</span>
                }
                <span class="cov8" title="1">responses[code] = ResponseInfo{Content: content}</span>
        }
        <span class="cov8" title="1">return responses</span>
}

// --- Conversion Utilities ---

func convertLibopenapiSchema(proxy *base.SchemaProxy) (domainSchema *Schema) <span class="cov8" title="1">{
        // Gracefully handle panics from the underlying library, which can occur with
        // invalid schemas (e.g., dangling references).
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        // On panic, ensure we return a nil schema.
                        domainSchema = nil
                }</span>
        }()

        <span class="cov8" title="1">if proxy == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">s, err := proxy.BuildSchema()
        if err != nil </span><span class="cov0" title="0">{
                return nil // Handle expected errors, like resolution failures.
        }</span>

        // This check is necessary because even if err is nil, the schema can be nil
        // in some edge cases (like a valid but empty proxy).
        <span class="cov8" title="1">if s == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">domainSchema = &amp;Schema{
                Type:        s.Type,
                Description: s.Description,
                Required:    s.Required,
        }

        if s.Properties != nil </span><span class="cov8" title="1">{
                for pair := s.Properties.First(); pair != nil; pair = pair.Next() </span><span class="cov8" title="1">{
                        domainSchema.Properties = append(domainSchema.Properties, Property{
                                Name:   pair.Key(),
                                Schema: convertLibopenapiSchema(pair.Value()),
                        })
                }</span>
        }

        <span class="cov8" title="1">if s.Items != nil &amp;&amp; s.Items.IsA() </span><span class="cov8" title="1">{
                domainSchema.Items = convertLibopenapiSchema(s.Items.A)
        }</span>

        <span class="cov8" title="1">for _, allOfProxy := range s.AllOf </span><span class="cov8" title="1">{
                domainSchema.AllOf = append(domainSchema.AllOf, convertLibopenapiSchema(allOfProxy))
        }</span>

        <span class="cov8" title="1">return domainSchema</span>
}

func convertToLibopenapiSchema(schema *Schema) *base.Schema <span class="cov8" title="1">{
        if schema == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">libSchema := &amp;base.Schema{
                Type:        schema.Type,
                Description: schema.Description,
                Required:    schema.Required,
        }

        if len(schema.Properties) &gt; 0 </span><span class="cov8" title="1">{
                libSchema.Properties = orderedmap.New[string, *base.SchemaProxy]()
                for _, prop := range schema.Properties </span><span class="cov8" title="1">{
                        libSchema.Properties.Set(prop.Name, base.CreateSchemaProxy(convertToLibopenapiSchema(prop.Schema)))
                }</span>
        }

        <span class="cov8" title="1">if schema.Items != nil </span><span class="cov8" title="1">{
                libSchema.Items = &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                        A: base.CreateSchemaProxy(convertToLibopenapiSchema(schema.Items)),
                }
        }</span>

        <span class="cov8" title="1">for _, allOfSchema := range schema.AllOf </span><span class="cov8" title="1">{
                libSchema.AllOf = append(libSchema.AllOf, base.CreateSchemaProxy(convertToLibopenapiSchema(allOfSchema)))
        }</span>

        <span class="cov8" title="1">return libSchema</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package oas2jsonschema

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strings"

        definitionv1alpha1 "github.com/krateoplatformops/oasgen-provider/apis/restdefinitions/v1alpha1"
        "github.com/krateoplatformops/oasgen-provider/internal/tools/text"
)

// OASSchemaGenerator orchestrates the generation of CRD schemas from an OpenAPI document.
type OASSchemaGenerator struct {
        config *GeneratorConfig
        doc    OASDocument
}

// NewOASSchemaGenerator creates a new, configured OASSchemaGenerator.
func NewOASSchemaGenerator(doc OASDocument, config *GeneratorConfig) *OASSchemaGenerator <span class="cov8" title="1">{
        return &amp;OASSchemaGenerator{
                doc:    doc,
                config: config,
        }
}</span>

// Generate orchestrates the full schema generation process.
func (g *OASSchemaGenerator) Generate(resource definitionv1alpha1.Resource, identifiers []string) (*GenerationResult, error) <span class="cov8" title="1">{
        var generationWarnings []error

        specSchema, warnings, err := g.generateSpecSchema(resource, identifiers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate spec schema: %w", err)
        }</span>
        <span class="cov8" title="1">generationWarnings = append(generationWarnings, warnings...)

        statusSchema, warnings, err := g.generateStatusSchema(resource, identifiers)
        if err != nil </span><span class="cov0" title="0">{
                // A failure to generate status schema is not considered a fatal error.
                generationWarnings = append(generationWarnings, fmt.Errorf("failed to generate status schema: %w", err))
        }</span>
        <span class="cov8" title="1">generationWarnings = append(generationWarnings, warnings...)

        authCRDSchemas, err := g.generateAuthCRDSchemas()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate auth CRD schemas: %w", err)
        }</span>

        <span class="cov8" title="1">validationWarnings := validateSchemas(g.doc, resource.VerbsDescription, g.config)

        return &amp;GenerationResult{
                SpecSchema:         specSchema,
                StatusSchema:       statusSchema,
                AuthCRDSchemas:     authCRDSchemas,
                GenerationWarnings: generationWarnings,
                ValidationWarnings: validationWarnings,
        }, nil</span>
}

// generateSpecSchema generates the complete spec schema for a given resource.
func (g *OASSchemaGenerator) generateSpecSchema(resource definitionv1alpha1.Resource, identifiers []string) ([]byte, []error, error) <span class="cov8" title="1">{
        var warnings []error

        baseSchema, err := g.getBaseSchemaForSpec(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("could not determine base schema for spec: %w", err)
        }</span>

        <span class="cov8" title="1">authCRDSchemas, err := g.generateAuthCRDSchemas()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("could not generate auth CRD schemas: %w", err)
        }</span>
        <span class="cov8" title="1">if len(authCRDSchemas) &gt; 0 </span><span class="cov8" title="1">{
                addAuthenticationRefs(baseSchema, authCRDSchemas)
        }</span>

        <span class="cov8" title="1">warnings = append(warnings, g.addParametersToSpec(baseSchema, resource)...)
        if g.config.IncludeIdentifiersInSpec </span><span class="cov8" title="1">{
                addIdentifiersToSpec(baseSchema, identifiers)
        }</span>

        <span class="cov8" title="1">if err := prepareSchemaForCRD(baseSchema); err != nil </span><span class="cov0" title="0">{
                return nil, warnings, fmt.Errorf("could not prepare spec schema for CRD: %w", err)
        }</span>

        <span class="cov8" title="1">byteSchema, err := GenerateJsonSchema(baseSchema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, warnings, fmt.Errorf("could not generate final JSON schema: %w", err)
        }</span>

        <span class="cov8" title="1">return byteSchema, warnings, nil</span>
}

// generateStatusSchema generates the complete status schema for a given resource.
func (g *OASSchemaGenerator) generateStatusSchema(resource definitionv1alpha1.Resource, identifiers []string) ([]byte, []error, error) <span class="cov8" title="1">{
        var warnings []error

        allStatusFields := append(identifiers, resource.AdditionalStatusFields...)
        if len(allStatusFields) == 0 </span><span class="cov0" title="0">{
                return nil, []error{SchemaGenerationError{Code: CodeNoStatusSchema, Message: "no identifiers or additional status fields defined, skipping status schema generation"}}, nil
        }</span>

        <span class="cov8" title="1">responseSchema, err := g.getBaseSchemaForStatus(resource.VerbsDescription)
        if err != nil </span><span class="cov8" title="1">{
                warnings = append(warnings, SchemaGenerationError{Message: fmt.Sprintf("schema validation warning: %v", err)})
        }</span>
        <span class="cov8" title="1">if responseSchema == nil </span><span class="cov8" title="1">{
                warnings = append(warnings, SchemaGenerationError{Code: CodeNoStatusSchema, Message: "could not find a GET or FINDBY response schema for status generation"})
        }</span>

        <span class="cov8" title="1">statusSchema, buildWarnings := g.buildStatusSchema(allStatusFields, responseSchema)
        warnings = append(warnings, buildWarnings...)

        if err := prepareSchemaForCRD(statusSchema); err != nil </span><span class="cov0" title="0">{
                return nil, warnings, fmt.Errorf("could not prepare status schema for CRD: %w", err)
        }</span>

        <span class="cov8" title="1">byteSchema, err := GenerateJsonSchema(statusSchema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, warnings, fmt.Errorf("could not generate final JSON schema for status: %w", err)
        }</span>

        <span class="cov8" title="1">return byteSchema, warnings, nil</span>
}

// getBaseSchemaForSpec returns the base schema for the spec, which is the request body of the 'create' action.
func (g *OASSchemaGenerator) getBaseSchemaForSpec(resource definitionv1alpha1.Resource) (*Schema, error) <span class="cov8" title="1">{
        for _, verb := range resource.VerbsDescription </span><span class="cov8" title="1">{
                if verb.Action != ActionCreate </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">path, ok := g.doc.FindPath(verb.Path)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("path '%s' not found in OpenAPI spec", verb.Path)
                }</span>
                <span class="cov8" title="1">ops := path.GetOperations()
                op, ok := ops[verb.Method]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("operation '%s' not found for path '%s'", verb.Method, verb.Path)
                }</span>

                <span class="cov8" title="1">rb := op.GetRequestBody()
                for _, mimeType := range g.config.AcceptedMIMETypes </span><span class="cov8" title="1">{
                        if schema, ok := rb.Content[mimeType]; ok </span><span class="cov8" title="1">{
                                if getPrimaryType(schema.Type) == "array" </span><span class="cov0" title="0">{
                                        schema.Properties = append(schema.Properties, Property{Name: "items", Schema: &amp;Schema{Type: []string{"array"}, Items: schema.Items}})
                                        schema.Type = []string{"object"}
                                }</span>
                                <span class="cov8" title="1">return schema, nil</span>
                        }
                }
        }
        <span class="cov8" title="1">return &amp;Schema{}, nil</span>
}

// generateAuthCRDSchemas generates the JSON schemas for the authentication CRDs.
func (g *OASSchemaGenerator) generateAuthCRDSchemas() (map[string][]byte, error) <span class="cov8" title="1">{
        secByteSchema := make(map[string][]byte)
        for _, secScheme := range g.doc.SecuritySchemes() </span><span class="cov8" title="1">{
                authSchema, err := g.generateAuthSchema(secScheme)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip unsupported security schemes
                        continue</span>
                }

                <span class="cov8" title="1">byteSchema, err := GenerateJsonSchema(authSchema)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("generating auth schema for '%s': %w", secScheme.Name, err)
                }</span>
                <span class="cov8" title="1">secByteSchema[secScheme.Name] = byteSchema</span>
        }
        <span class="cov8" title="1">return secByteSchema, nil</span>
}

// generateAuthSchema generates the JSON schema for a given security scheme.
func (g *OASSchemaGenerator) generateAuthSchema(info SecuritySchemeInfo) (*Schema, error) <span class="cov8" title="1">{
        if info.Type == SchemeTypeHTTP &amp;&amp; info.Scheme == "basic" </span><span class="cov8" title="1">{
                return reflectSchema(reflect.TypeOf(BasicAuth{}))
        }</span>

        <span class="cov8" title="1">if info.Type == SchemeTypeHTTP &amp;&amp; info.Scheme == "bearer" </span><span class="cov8" title="1">{
                return reflectSchema(reflect.TypeOf(BearerAuth{}))
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported security scheme type: %s", info.Type)</span>
}

// addAuthenticationRefs adds the authenticationRefs property to the schema.
func addAuthenticationRefs(schema *Schema, authCRDSchemas map[string][]byte) <span class="cov8" title="1">{
        var authRefsProps []Property
        for key := range authCRDSchemas </span><span class="cov8" title="1">{
                authRefsProps = append(authRefsProps, Property{Name: fmt.Sprintf("%sRef", text.FirstToLower(key)), Schema: &amp;Schema{Type: []string{"string"}}})
        }</span>
        <span class="cov8" title="1">authRefsSchema := &amp;Schema{
                Type:        []string{"object"},
                Description: "AuthenticationRefs represent the reference to a CR containing the authentication information. One authentication method must be set.",
                Properties:  authRefsProps,
        }
        schema.Properties = append(schema.Properties, Property{Name: "authenticationRefs", Schema: authRefsSchema})
        schema.Required = append(schema.Required, "authenticationRefs")</span>
}

// addParametersToSpec adds the parameters from all verbs to the schema.
func (g *OASSchemaGenerator) addParametersToSpec(schema *Schema, resource definitionv1alpha1.Resource) []error <span class="cov8" title="1">{
        var warnings []error
        for _, verb := range resource.VerbsDescription </span><span class="cov8" title="1">{
                path, ok := g.doc.FindPath(verb.Path)
                if !ok </span><span class="cov0" title="0">{
                        warnings = append(warnings, SchemaGenerationError{Code: CodePathNotFound, Message: fmt.Sprintf("path '%s' in RestDefinition not found", verb.Path)})
                        continue</span>
                }
                <span class="cov8" title="1">ops := path.GetOperations()
                for opName, op := range ops </span><span class="cov8" title="1">{
                        for _, param := range op.GetParameters() </span><span class="cov8" title="1">{
                                found := false
                                for _, p := range schema.Properties </span><span class="cov8" title="1">{
                                        if p.Name == param.Name </span><span class="cov0" title="0">{
                                                warnings = append(warnings, SchemaGenerationError{Code: CodeDuplicateParameter, Message: fmt.Sprintf("parameter '%s' already exists, skipping", param.Name)})
                                                found = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                        param.Schema.Description = fmt.Sprintf("PARAMETER: %s, VERB: %s - %s", param.In, text.CapitaliseFirstLetter(opName), param.Description)
                                        schema.Properties = append(schema.Properties, Property{Name: param.Name, Schema: param.Schema})
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return warnings</span>
}

// addIdentifiersToSpec adds the identifiers to the schema.
func addIdentifiersToSpec(schema *Schema, identifiers []string) <span class="cov8" title="1">{
        for _, identifier := range identifiers </span><span class="cov8" title="1">{
                found := false
                for _, p := range schema.Properties </span><span class="cov0" title="0">{
                        if p.Name == identifier </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        schema.Properties = append(schema.Properties, Property{
                                Name: identifier,
                                Schema: &amp;Schema{
                                        Description: fmt.Sprintf("IDENTIFIER: %s", identifier),
                                        Type:        []string{"string"},
                                },
                        })
                }</span>
        }
}

// getBaseSchemaForStatus returns the base schema for the status, which is the response body of the 'get' or 'findby' action.
func (g *OASSchemaGenerator) getBaseSchemaForStatus(verbs []definitionv1alpha1.VerbsDescription) (*Schema, error) <span class="cov8" title="1">{
        actions := []string{ActionGet, ActionFindBy}
        for _, action := range actions </span><span class="cov8" title="1">{
                schema, err := extractSchemaForAction(g.doc, verbs, action, g.config)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if schema != nil </span><span class="cov8" title="1">{
                        return schema, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

// buildStatusSchema builds the status schema from the response schema and the list of status fields.
func (g *OASSchemaGenerator) buildStatusSchema(allStatusFields []string, responseSchema *Schema) (*Schema, []error) <span class="cov8" title="1">{
        var warnings []error
        var props []Property
        for _, fieldName := range allStatusFields </span><span class="cov8" title="1">{
                found := false
                if responseSchema != nil </span><span class="cov8" title="1">{
                        for _, p := range responseSchema.Properties </span><span class="cov8" title="1">{
                                if p.Name == fieldName </span><span class="cov8" title="1">{
                                        props = append(props, p)
                                        found = true
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        warnings = append(warnings, SchemaGenerationError{Code: CodeStatusFieldNotFound, Message: fmt.Sprintf("status field '%s' not found in response, defaulting to string", fieldName)})
                        props = append(props, Property{Name: fieldName, Schema: &amp;Schema{Type: []string{"string"}}})
                }</span>
        }
        <span class="cov8" title="1">return &amp;Schema{Type: []string{"object"}, Properties: props}, warnings</span>
}

// GenerateJsonSchema converts a domain-specific Schema object into a JSON schema byte slice.
func GenerateJsonSchema(schema *Schema) ([]byte, error) <span class="cov8" title="1">{
        schemaMap, err := schemaToMap(schema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert schema to map: %w", err)
        }</span>

        // Add standard JSON schema fields
        <span class="cov8" title="1">schemaMap["$schema"] = "http://json-schema.org/draft-07/schema#"

        return json.MarshalIndent(schemaMap, "", "  ")</span>
}

// schemaToMap converts our domain-specific Schema object into a map[string]interface{}
// suitable for JSON marshalling. This is the key to making the generator library-agnostic.
func schemaToMap(schema *Schema) (map[string]interface{}, error) <span class="cov8" title="1">{
        if schema == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">m := make(map[string]interface{})

        if len(schema.Type) &gt; 0 </span><span class="cov8" title="1">{
                // Handle single vs. multiple types for JSON output
                if len(schema.Type) == 1 </span><span class="cov8" title="1">{
                        m["type"] = schema.Type[0]
                }</span> else<span class="cov0" title="0"> {
                        m["type"] = schema.Type
                }</span>
        }

        <span class="cov8" title="1">if schema.Description != "" </span><span class="cov8" title="1">{
                m["description"] = schema.Description
        }</span>

        <span class="cov8" title="1">if len(schema.Required) &gt; 0 </span><span class="cov8" title="1">{
                m["required"] = schema.Required
        }</span>

        <span class="cov8" title="1">if len(schema.Properties) &gt; 0 </span><span class="cov8" title="1">{
                props := make(map[string]interface{})
                for _, p := range schema.Properties </span><span class="cov8" title="1">{
                        propMap, err := schemaToMap(p.Schema)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("could not convert property '%s': %w", p.Name, err)
                        }</span>
                        <span class="cov8" title="1">if propMap != nil </span><span class="cov8" title="1">{
                                props[p.Name] = propMap
                        }</span>
                }
                <span class="cov8" title="1">m["properties"] = props</span>
        }

        <span class="cov8" title="1">if schema.Items != nil </span><span class="cov0" title="0">{
                itemsMap, err := schemaToMap(schema.Items)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not convert items schema: %w", err)
                }</span>
                <span class="cov0" title="0">if itemsMap != nil </span><span class="cov0" title="0">{
                        m["items"] = itemsMap
                }</span>
        }

        <span class="cov8" title="1">if len(schema.AllOf) &gt; 0 </span><span class="cov0" title="0">{
                var allOfList []interface{}
                for _, s := range schema.AllOf </span><span class="cov0" title="0">{
                        allOfMap, err := schemaToMap(s)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("could not convert allOf item: %w", err)
                        }</span>
                        <span class="cov0" title="0">if allOfMap != nil </span><span class="cov0" title="0">{
                                allOfList = append(allOfList, allOfMap)
                        }</span>
                }
                <span class="cov0" title="0">m["allOf"] = allOfList</span>
        }

        <span class="cov8" title="1">return m, nil</span>
}

// prepareSchemaForCRD recursively traverses a schema and prepares it for use in a Kubernetes CRD.
func prepareSchemaForCRD(schema *Schema) error <span class="cov8" title="1">{
        if schema == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if getPrimaryType(schema.Type) == "number" </span><span class="cov8" title="1">{
                convertNumberToInteger(schema)
        }</span>

        <span class="cov8" title="1">if getPrimaryType(schema.Type) == "array" </span><span class="cov8" title="1">{
                return prepareSchemaForCRD(schema.Items)
        }</span>

        <span class="cov8" title="1">for _, prop := range schema.Properties </span><span class="cov8" title="1">{
                if err := prepareSchemaForCRD(prop.Schema); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">for _, allOfSchema := range schema.AllOf </span><span class="cov8" title="1">{
                if err := prepareSchemaForCRD(allOfSchema); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">schema.Properties = append(schema.Properties, allOfSchema.Properties...)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// convertNumberToInteger converts "number" types to "integer" types.
func convertNumberToInteger(schema *Schema) <span class="cov8" title="1">{
        for i, t := range schema.Type </span><span class="cov8" title="1">{
                if t == "number" </span><span class="cov8" title="1">{
                        schema.Type[i] = "integer"
                }</span>
        }
}

// reflectSchema generates a schema from a Go type using reflection.
func reflectSchema(t reflect.Type) (*Schema, error) <span class="cov8" title="1">{
        if t == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">props, req, err := buildSchemaProperties(t)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Schema{
                Type:       []string{"object"},
                Properties: props,
                Required:   req,
        }, nil</span>
}

// buildSchemaProperties recursively builds the properties of a schema from a Go type.
func buildSchemaProperties(t reflect.Type) ([]Property, []string, error) <span class="cov8" title="1">{
        var props []Property
        var required []string
        var inlineRequired []string

        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov8" title="1">{
                field := t.Field(i)
                fieldType := field.Type
                fieldName := field.Tag.Get("json")
                split := strings.Split(fieldName, ",")
                if len(split) &gt; 1 </span><span class="cov8" title="1">{
                        fieldName = split[0]
                }</span> else<span class="cov8" title="1"> {
                        required = append(required, fieldName)
                }</span>

                <span class="cov8" title="1">if fieldType.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                        fieldProps, req, err := buildSchemaProperties(fieldType)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>

                        <span class="cov8" title="1">if fieldName == "" </span><span class="cov8" title="1">{
                                props = append(props, fieldProps...)
                                inlineRequired = append(inlineRequired, req...)
                        }</span> else<span class="cov8" title="1"> {
                                props = append(props, Property{
                                        Name: fieldName,
                                        Schema: &amp;Schema{
                                                Type:       []string{"object"},
                                                Properties: fieldProps,
                                                Required:   req,
                                        },
                                })
                        }</span>
                } else<span class="cov8" title="1"> {
                        props = append(props, Property{
                                Name:   fieldName,
                                Schema: &amp;Schema{Type: []string{fieldType.Name()}},
                        })
                }</span>
        }
        <span class="cov8" title="1">return props, append(required, inlineRequired...), nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package oas2jsonschema

import "github.com/krateoplatformops/crdgen"

// OASSpecJsonSchemaGetter returns a JsonSchemaGetter for the spec schema.
func (r *GenerationResult) OASSpecJsonSchemaGetter() crdgen.JsonSchemaGetter <span class="cov8" title="1">{
        return &amp;oasSpecJsonSchemaGetter{
                result: r,
        }
}</span>

var _ crdgen.JsonSchemaGetter = (*oasSpecJsonSchemaGetter)(nil)

type oasSpecJsonSchemaGetter struct {
        result *GenerationResult
}

func (a *oasSpecJsonSchemaGetter) Get() ([]byte, error) <span class="cov8" title="1">{
        return a.result.SpecSchema, nil
}</span>

// OASStatusJsonSchemaGetter returns a JsonSchemaGetter for the status schema.
func (r *GenerationResult) OASStatusJsonSchemaGetter() crdgen.JsonSchemaGetter <span class="cov8" title="1">{
        return &amp;oasStatusJsonSchemaGetter{
                result: r,
        }
}</span>

var _ crdgen.JsonSchemaGetter = (*oasStatusJsonSchemaGetter)(nil)

type oasStatusJsonSchemaGetter struct {
        result *GenerationResult
}

func (a *oasStatusJsonSchemaGetter) Get() ([]byte, error) <span class="cov8" title="1">{
        return a.result.StatusSchema, nil
}</span>

// OASAuthCRDSchemaGetter returns a JsonSchemaGetter for a specific auth schema.
func (r *GenerationResult) OASAuthCRDSchemaGetter(secSchemaName string) crdgen.JsonSchemaGetter <span class="cov8" title="1">{
        return &amp;oasAuthCRDSchemaGetter{
                result:        r,
                secSchemaName: secSchemaName,
        }
}</span>

var _ crdgen.JsonSchemaGetter = (*oasAuthCRDSchemaGetter)(nil)

type oasAuthCRDSchemaGetter struct {
        result        *GenerationResult
        secSchemaName string
}

func (a *oasAuthCRDSchemaGetter) Get() ([]byte, error) <span class="cov8" title="1">{
        return a.result.AuthCRDSchemas[a.secSchemaName], nil
}</span>

// StaticJsonSchemaGetter returns a getter that returns nil.
func StaticJsonSchemaGetter() crdgen.JsonSchemaGetter <span class="cov8" title="1">{
        return &amp;staticJsonSchemaGetter{}
}</span>

var _ crdgen.JsonSchemaGetter = (*staticJsonSchemaGetter)(nil)

type staticJsonSchemaGetter struct{}

func (f *staticJsonSchemaGetter) Get() ([]byte, error) <span class="cov8" title="1">{
        return nil, nil
}</pre>
		
		<pre class="file" id="file3" style="display: none">package oas2jsonschema

import (
        "fmt"
        "strings"

        definitionv1alpha1 "github.com/krateoplatformops/oasgen-provider/apis/restdefinitions/v1alpha1"
)

const (
        ActionGet    = "get"
        ActionFindBy = "findby"
        ActionCreate = "create"
        ActionUpdate = "update"
)

func determineBaseAction(verbs []definitionv1alpha1.VerbsDescription) (string, error) <span class="cov8" title="1">{
        hasGet := false
        hasFindBy := false
        for _, verb := range verbs </span><span class="cov8" title="1">{
                if verb.Action == ActionGet </span><span class="cov8" title="1">{
                        hasGet = true
                        break</span> // 'get' takes precedence
                }
                <span class="cov8" title="1">if verb.Action == ActionFindBy </span><span class="cov8" title="1">{
                        hasFindBy = true
                }</span>
        }

        <span class="cov8" title="1">if hasGet </span><span class="cov8" title="1">{
                return ActionGet, nil
        }</span>
        <span class="cov8" title="1">if hasFindBy </span><span class="cov8" title="1">{
                return ActionFindBy, nil
        }</span>

        <span class="cov8" title="1">return "", SchemaValidationError{
                Code:    CodeMissingBaseAction,
                Message: "no 'get' or 'findby' action found to serve as a base for schema validation",
        }</span>
}

func validateSchemas(doc OASDocument, verbs []definitionv1alpha1.VerbsDescription, config *GeneratorConfig) []error <span class="cov8" title="1">{
        baseAction, err := determineBaseAction(verbs)
        if err != nil </span><span class="cov8" title="1">{
                return []error{err}
        }</span>

        <span class="cov8" title="1">var errors []error
        for _, verb := range verbs </span><span class="cov8" title="1">{
                // Determine if the current verb is one we need to compare against the base.
                isComparable := verb.Action == ActionCreate || verb.Action == ActionUpdate
                if baseAction == ActionGet &amp;&amp; verb.Action == ActionFindBy </span><span class="cov8" title="1">{
                        isComparable = true
                }</span>

                <span class="cov8" title="1">if isComparable </span><span class="cov8" title="1">{
                        errors = append(errors, compareActionResponseSchemas(doc, verbs, verb.Action, baseAction, config)...)
                }</span>
        }

        <span class="cov8" title="1">return errors</span>
}

func compareActionResponseSchemas(doc OASDocument, verbs []definitionv1alpha1.VerbsDescription, action1, action2 string, config *GeneratorConfig) []error <span class="cov8" title="1">{
        schema2, err := extractSchemaForAction(doc, verbs, action2, config)
        if err != nil </span><span class="cov8" title="1">{
                return []error{SchemaValidationError{
                        Code:    CodeActionSchemaMissing,
                        Message: fmt.Sprintf("could not extract base schema for action '%s': %v", action2, err),
                }}
        }</span>

        <span class="cov8" title="1">schema1, err := extractSchemaForAction(doc, verbs, action1, config)
        if err != nil </span><span class="cov8" title="1">{
                return []error{SchemaValidationError{
                        Code:    CodeActionSchemaMissing,
                        Message: fmt.Sprintf("could not extract schema for action '%s' to compare: %v", action1, err),
                }}
        }</span>

        <span class="cov8" title="1">return compareSchemas(".", schema1, schema2)</span>
}

func compareSchemas(path string, schema1, schema2 *Schema) []error <span class="cov8" title="1">{
        var errors []error

        if schema1 == nil &amp;&amp; schema2 == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if schema1 == nil </span><span class="cov8" title="1">{
                return []error{SchemaValidationError{Path: path, Message: "first schema is nil"}}
        }</span>
        <span class="cov8" title="1">if schema2 == nil </span><span class="cov8" title="1">{
                return []error{SchemaValidationError{Path: path, Message: "second schema is nil"}}
        }</span>

        <span class="cov8" title="1">schema1HasProps := len(schema1.Properties) &gt; 0
        schema2HasProps := len(schema2.Properties) &gt; 0

        if !schema1HasProps &amp;&amp; !schema2HasProps </span><span class="cov8" title="1">{
                if !areTypesCompatible(schema1.Type, schema2.Type) </span><span class="cov8" title="1">{
                        errors = append(errors, SchemaValidationError{
                                Path:     path,
                                Code:     CodeTypeMismatch,
                                Message:  fmt.Sprintf("type mismatch: first schema types are '%v', second are '%v'", schema1.Type, schema2.Type),
                                Got:      schema1.Type,
                                Expected: schema2.Type,
                        })
                }</span>
                <span class="cov8" title="1">return errors</span>
        }

        <span class="cov8" title="1">if schema1HasProps != schema2HasProps </span><span class="cov8" title="1">{
                errors = append(errors, SchemaValidationError{
                        Path:    path,
                        Code:    CodePropertyMismatch,
                        Message: "one schema has properties but the other does not",
                })
                return errors
        }</span>

        <span class="cov8" title="1">props2 := make(map[string]Property)
        for _, p := range schema2.Properties </span><span class="cov8" title="1">{
                props2[p.Name] = p
        }</span>

        <span class="cov8" title="1">for _, prop1 := range schema1.Properties </span><span class="cov8" title="1">{
                prop2, ok := props2[prop1.Name]
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">currentPath := buildPath(path, prop1.Name)

                if prop1.Schema == nil || prop2.Schema == nil </span><span class="cov8" title="1">{
                        if prop1.Schema != prop2.Schema </span><span class="cov8" title="1">{ // One is nil, the other is not
                                errors = append(errors, SchemaValidationError{
                                        Path:    currentPath,
                                        Code:    CodePropertyMismatch,
                                        Message: fmt.Sprintf("schema for property '%s' is nil in one definition but not the other", currentPath),
                                })
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if !areTypesCompatible(prop1.Schema.Type, prop2.Schema.Type) </span><span class="cov8" title="1">{
                        errors = append(errors, SchemaValidationError{
                                Path:     currentPath,
                                Code:     CodeTypeMismatch,
                                Message:  fmt.Sprintf("type mismatch for field '%s': first schema types are '%v', second are '%v'", currentPath, prop1.Schema.Type, prop2.Schema.Type),
                                Got:      prop1.Schema.Type,
                                Expected: prop2.Schema.Type,
                        })
                        continue</span>
                }

                <span class="cov8" title="1">switch getPrimaryType(prop1.Schema.Type) </span>{
                case "object":<span class="cov8" title="1">
                        errors = append(errors, compareSchemas(currentPath, prop1.Schema, prop2.Schema)...)</span>
                case "array":<span class="cov8" title="1">
                        if prop1.Schema.Items != nil &amp;&amp; prop2.Schema.Items != nil </span><span class="cov8" title="1">{
                                errors = append(errors, compareSchemas(currentPath, prop1.Schema.Items, prop2.Schema.Items)...)
                        }</span> else<span class="cov8" title="1"> if prop1.Schema.Items != nil &amp;&amp; prop2.Schema.Items == nil </span><span class="cov8" title="1">{
                                errors = append(errors, SchemaValidationError{
                                        Path:    currentPath,
                                        Code:    CodeMissingArrayItems,
                                        Message: "second schema has no items for array",
                                })
                        }</span> else<span class="cov8" title="1"> if prop1.Schema.Items == nil &amp;&amp; prop2.Schema.Items != nil </span><span class="cov8" title="1">{
                                errors = append(errors, SchemaValidationError{
                                        Path:    currentPath,
                                        Code:    CodeMissingArrayItems,
                                        Message: "first schema has no items for array",
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">return errors</span>
}

func buildPath(base, field string) string <span class="cov8" title="1">{
        if base == "." </span><span class="cov8" title="1">{
                return field
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s.%s", base, field)</span>
}

func getPrimaryType(types []string) string <span class="cov8" title="1">{
        for _, t := range types </span><span class="cov8" title="1">{
                if t != "null" </span><span class="cov8" title="1">{
                        return t
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// areTypesCompatible checks if two slices of types are compatible based on their primary non-null type.
// The compatibility rules are:
// 1. If both have a primary type (e.g., "string", "object"), they must be identical.
// 2. If one has a primary type and the other does not (i.e., is only "null" or empty), they are incompatible.
// 3. If neither has a primary type, they are compatible (e.g., ["null"] vs []).
func areTypesCompatible(types1, types2 []string) bool <span class="cov8" title="1">{
        primaryType1 := getPrimaryType(types1)
        primaryType2 := getPrimaryType(types2)

        // If both have a primary type, they must be the same.
        // If one has a primary type and the other doesn't, they are not compatible.
        return primaryType1 == primaryType2
}</span>

func extractSchemaForAction(doc OASDocument, verbs []definitionv1alpha1.VerbsDescription, targetAction string, config *GeneratorConfig) (*Schema, error) <span class="cov8" title="1">{
        var verbFound bool
        for _, verb := range verbs </span><span class="cov8" title="1">{
                if !strings.EqualFold(verb.Action, targetAction) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">verbFound = true

                path, ok := doc.FindPath(verb.Path)
                if !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("path '%s' not found in OAS document", verb.Path)
                }</span>

                <span class="cov8" title="1">ops := path.GetOperations()
                op, ok := ops[strings.ToLower(verb.Method)]
                if !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("method '%s' not found for path '%s'", verb.Method, verb.Path)
                }</span>

                <span class="cov8" title="1">responses := op.GetResponses()
                if responses == nil </span><span class="cov8" title="1">{
                        continue</span> // Or return an error if responses are expected
                }

                <span class="cov8" title="1">for _, code := range config.SuccessCodes </span><span class="cov8" title="1">{
                        resp, ok := responses[code]
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">for _, mimeType := range config.AcceptedMIMETypes </span><span class="cov8" title="1">{
                                schema, ok := resp.Content[mimeType]
                                if !ok || schema == nil </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                // If a schema is found, return it immediately.
                                <span class="cov8" title="1">if strings.EqualFold(targetAction, ActionFindBy) &amp;&amp; schema.Items != nil </span><span class="cov8" title="1">{
                                        return schema.Items, nil
                                }</span>
                                <span class="cov8" title="1">return schema, nil</span>
                        }
                }
        }

        <span class="cov8" title="1">if !verbFound </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("action '%s' not defined in resource verbs", targetAction)
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("no suitable response schema found for action '%s'", targetAction)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">
package oas2jsonschema

// --- Mock Implementations ---

// mockOperation implements the Operation interface for testing.
type mockOperation struct {
        Parameters  []ParameterInfo
        RequestBody RequestBodyInfo
        Responses   map[int]ResponseInfo
}

func (m *mockOperation) GetParameters() []ParameterInfo     <span class="cov8" title="1">{ return m.Parameters }</span>
func (m *mockOperation) GetRequestBody() RequestBodyInfo    <span class="cov8" title="1">{ return m.RequestBody }</span>
func (m *mockOperation) GetResponses() map[int]ResponseInfo <span class="cov8" title="1">{ return m.Responses }</span>

// mockPathItem implements the PathItem interface for testing.
type mockPathItem struct {
        Ops map[string]Operation
}

func (m *mockPathItem) GetOperations() map[string]Operation <span class="cov8" title="1">{ return m.Ops }</span>

// mockOASDocument implements the OASDocument interface for testing.
type mockOASDocument struct {
        Paths           map[string]*mockPathItem
        securitySchemes []SecuritySchemeInfo
}

func (m *mockOASDocument) FindPath(path string) (PathItem, bool) <span class="cov8" title="1">{
        p, ok := m.Paths[path]
        return p, ok
}</span>

func (m *mockOASDocument) SecuritySchemes() []SecuritySchemeInfo <span class="cov8" title="1">{
        return m.securitySchemes
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package oas2jsonschema

import (
        "fmt"

        rtv1 "github.com/krateoplatformops/provider-runtime/apis/common/v1"
)

// GeneratorConfig holds configuration options for the schema generator.
type GeneratorConfig struct {
        AcceptedMIMETypes        []string
        SuccessCodes             []int
        IncludeIdentifiersInSpec bool
}

// DefaultGeneratorConfig returns a new GeneratorConfig with default values.
func DefaultGeneratorConfig() *GeneratorConfig <span class="cov8" title="1">{
        return &amp;GeneratorConfig{
                AcceptedMIMETypes:        []string{"application/json"},
                SuccessCodes:             []int{200, 201},
                IncludeIdentifiersInSpec: false,
        }
}</span>

// --- Library-Agnostic Domain Models ---

// Property represents a single key-value pair in a schema's properties.
// Using a slice of these preserves order.
type Property struct {
        Name   string
        Schema *Schema
}

// Schema is a library-agnostic representation of a JSON Schema Object, which is used
// within the OpenAPI specification to define the structure of data payloads.
// It is not a representation of the entire OpenAPI document itself.
type Schema struct {
        Type        []string
        Description string
        Properties  []Property
        Items       *Schema
        AllOf       []*Schema
        Required    []string
}

// SecuritySchemeType defines the type of a security scheme (e.g., http, apiKey).
type SecuritySchemeType string

// Source: https://swagger.io/docs/specification/v3_0/authentication/
const (
        SchemeTypeHTTP          SecuritySchemeType = "http"
        SchemeTypeAPIKey        SecuritySchemeType = "apiKey"        // Currently not supported
        SchemeTypeOAuth2        SecuritySchemeType = "oauth2"        // Currently not supported
        SchemeTypeOpenIDConnect SecuritySchemeType = "openIdConnect" // Currently not supported
)

// SecuritySchemeInfo is a library-agnostic representation of a security scheme.
// It mirrors the structure of an OpenAPI security scheme.
// In this Go code, it is a "sum type" that captures different security scheme types.
// The 'Type' field is the high-level category (e.g., 'http', 'apiKey', 'oauth2', 'openIdConnect').
// The 'Scheme' field is a sub-detail used only when Type is 'http' (e.g., 'basic', 'bearer').
// Other fields like 'In' and 'ParamName' are used for other types (e.g., 'apiKey').
type SecuritySchemeInfo struct {
        Name      string
        Type      SecuritySchemeType
        Scheme    string // e.g., "basic", "bearer"
        In        string // e.g., "header", "query"
        ParamName string // The name of the header or query parameter (for apiKey)
}

// ParameterInfo is a library-agnostic representation of an API parameter.
type ParameterInfo struct {
        Name        string
        In          string
        Description string
        Schema      *Schema
}

// RequestBodyInfo is a library-agnostic representation of a request body.
// Type name reflect the OpenAPI spec's 'requestBody' object
type RequestBodyInfo struct {
        Content map[string]*Schema
}

// ResponseInfo is a library-agnostic representation of a response.
// Type name reflects the OpenAPI spec's single response object under the 'responses' map.
type ResponseInfo struct {
        Content map[string]*Schema
}

// GenerationResult holds the output of the schema generation process.
type GenerationResult struct {
        SpecSchema         []byte
        StatusSchema       []byte
        AuthCRDSchemas     map[string][]byte
        GenerationWarnings []error
        ValidationWarnings []error
}

// GenerationCode defines a machine-readable code for the type of generation warning.
type GenerationCode string

const (
        // CodeDuplicateParameter indicates that a parameter is defined in multiple verbs.
        CodeDuplicateParameter GenerationCode = "DuplicateParameter"
        // CodePathNotFound indicates that a path specified in the RestDefinition was not found in the OpenAPI spec.
        CodePathNotFound GenerationCode = "PathNotFound"
        // CodeStatusFieldNotFound indicates that a status field was not found in the response schema.
        CodeStatusFieldNotFound GenerationCode = "StatusFieldNotFound"
        // CodeNoRootSchema indicates that no base schema could be found for the spec.
        CodeNoRootSchema GenerationCode = "NoRootSchema"
        // CodeNoStatusSchema indicates that no schema could be found for the status.
        CodeNoStatusSchema GenerationCode = "NoStatusSchema"
)

// SchemaGenerationError defines a structured error for schema generation warnings.
type SchemaGenerationError struct {
        Path    string
        Code    GenerationCode
        Message string

        Got      any
        Expected any
}

func (e SchemaGenerationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("generation error at %s: %s", e.Path, e.Message)
}</span>

// ValidationCode defines a machine-readable code for the type of error.
type ValidationCode string

const (
        // CodeMissingBaseAction indicates that no 'get' or 'findby' action was found.
        CodeMissingBaseAction ValidationCode = "MissingBaseAction"
        // CodeActionSchemaMissing indicates that the schema for a specific action is nil.
        CodeActionSchemaMissing ValidationCode = "ActionSchemaMissing"
        // CodeTypeMismatch indicates a type mismatch between two schemas.
        CodeTypeMismatch ValidationCode = "TypeMismatch"
        // CodePropertyMismatch indicates that one schema has properties while the other does not.
        CodePropertyMismatch ValidationCode = "PropertyMismatch"
        // CodeMissingArrayItems indicates that one schema has array items while the other does not.
        CodeMissingArrayItems ValidationCode = "MissingArrayItems"
)

// SchemaValidationError defines a structured error for schema validation.
type SchemaValidationError struct {
        Path    string
        Code    ValidationCode
        Message string

        Got      any
        Expected any
}

func (e SchemaValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("validation error at %s: %s", e.Path, e.Message)
}</span>

type BasicAuth struct {
        Username    string                 `json:"username"`
        PasswordRef rtv1.SecretKeySelector `json:"passwordRef"`
}

type BearerAuth struct {
        TokenRef rtv1.SecretKeySelector `json:"tokenRef"`
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
